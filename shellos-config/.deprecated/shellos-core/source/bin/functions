#!/bin/bash
#
# Global functions common for all projects. These functions may depend on
# variables and constants.

################################################################################
## private routines
##

# Sets ownership of a file.
#
# parameters:
#   $1 file
function _set_ownership() {

    local file=$1
    local permissions="644"
    local _owner="root"

    [ -n "$owner" ] && _owner=$owner
    [ "$(str_ends $file $CRONTAB_JOBS_FILE)" == "yes" ] && permissions="644" && _owner="root"
    [ "$(str_ends $file $CRONTAB_VARIABLES_FILE)" == "yes" ] && permissions="644" && _owner="root"
    [ "$(str_ends $file $DATABASE_USERS_FILE)" == "yes" ] && permissions="600" && _owner="root"
    [ "$(str_ends $file $HASH_DIRECTORIES_FILE)" == "yes" ] && permissions="600" && _owner="root"
    [ "$(str_ends $file $HASH_FILES_FILE)" == "yes" ] && permissions="600" && _owner="root"
    [ "$(str_ends $file $PROFILE_FILE)" == "yes" ] && permissions="644" && _owner="root"
    [ "$(str_ends $file $REPOSITORIES_FILE)" == "yes" ] && permissions="600" && _owner="root"
    [ "$(str_ends $file $SHELLOS_CONF_FILE)" == "yes" ] && permissions="600" && _owner="root"
    [ "$(str_ends $file $FIREWALL_MODE_FILE)" == "yes" ] && permissions="600" && _owner="root"
    [ "$(str_ends $file .lock)" == "yes" ] && permissions="600" && _owner="root"
    [ "$(str_ends $file .tmp)" == "yes" ] && permissions="600" && _owner="root"

    chmod $permissions $file > /dev/null 2&>1
    chown $_owner:$_owner $file > /dev/null 2&>1
}

# Sets ownership of all sensitive configuration files.
#
function _set_predefined_ownership() {

    local files="$DATABASE_USERS_FILE $HASH_DIRECTORIES_FILE $HASH_FILES_FILE $REPOSITORIES_FILE $SHELLOS_CONF_FILE $FIREWALL_MODE_FILE $JOB_LOCK_DIR/*.lock $TMP_DIR/*.tmp"
    for file in $files; do
        chmod 600 $file > /dev/null 2&>1
        chown root:root $file > /dev/null 2&>1
    done
    
    files="$CRONTAB_JOBS_FILE $CRONTAB_VARIABLES_FILE $PROFILE_FILE"
    for file in $files; do
        chmod 644 $file > /dev/null 2&>1
        chown root:root $file > /dev/null 2&>1
    done
}

################################################################################
## base routines
##

# Allows to sleep in increments of milliseconds.
#
# parameters:
#   $1 milliseconds
function usleep() {

    local ms=$1
    local sec=$(echo "scale=2; $ms / 1000" | bc)

    perl -e "select(undef,undef,undef,$sec)"
}

################################################################################
## numeric routines
##

# Converts hexadecimal to decimal number.
#
# parameters:
#   $1 hexadecimal number
function h2d() {

    local hex=$1
    hex=$(upper $hex)
    local dec=$(echo "ibase=16; $hex" | bc)

    echo $dec
}

# Converts decimal to hexadecimal number.
#
# parameters:
#   $1 decimal number
function d2h() {

    local dec=$1
    local hex=$(echo "ibase=10; obase=16; $dec" | bc)
    hex=$(lower $hex)

    echo $hex
}

################################################################################
## string routines
##

# Returns random string (A-Za-z0-9) with the given length.
#
# parameters:
#   $1 length
function random() {

    str=</dev/urandom tr -dc A-Za-z0-9 | (head -c $ > /dev/null 2>&1 || head -c $1)
    echo $str
}

# Makes sure that string meets certain criteria.
#
# parameters:
#   $1 string
#   $2 character to be used as a replacement
#   $3 max length
#   --allowed-characters <characters>
function sanitise() {

    local str=$1
    local char=$2
    local len=255
    local allowed_characters=""

    # get max length
    if [ "$3" != "" ] && [ "$3" != "--allowed-characters" ]; then
        len=$3
    fi
    # get allowed characters
    while [ "$1" != "" ]; do
        case $1 in
            --allowed-characters)   shift; allowed_characters=$1
                                    ;;
        esac
        shift
    done

    local sanitised=${str//+([^A-Za-z0-9$allowed_characters])/$char}
    if [ -n "$len" ]; then
        sanitised=`echo $sanitised | cut -c1-$len`
    fi
    echo $sanitised | tr '[:upper:]' '[:lower:]'
}

# Returns substring by removing its prefix and suffix.
#
# parameters:
#   $1 string
#   $2 prefix as string
#   $3 suffix as string
function substring() {

    local str="${1#${1%${2}*}${2}}"
    echo "${str%${3}*}"
}

# Checks if string contains another string.
#
# parameters:
#   $1 string
#   $2 search string
function contains() {

    local count=$(echo "$1" | grep "$2" | wc -l)
    if [ $count -gt 0 ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Checks if string begins with another string.
#
# parameters:
#   $1 string
#   $2 search string
function str_begins() {

    local count=$(echo "$1" | grep "^$2" | wc -l)
    if [ $count -gt 0 ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Checks if string ends with another string.
#
# parameters:
#   $1 string
#   $2 search string
function str_ends() {

    local count=$(echo "$1" | grep "$2$" | wc -l)
    if [ $count -gt 0 ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Removes whitespaces from the begining and the end of a string.
#
# parameters:
#   $1 string
function trim() {

    local str="$1"
    str=$(sed -e 's/^[[:space:]]*//' <<<"$str")
    str=$(sed -e 's/[[:space:]]*$//' <<<"$str")

    echo "$str"
}

# Converts string to lower case.
#
# parameters:
#   $1 string
function lower() {

    local str="$1"
    str=$(echo $str | tr '[:upper:]' '[:lower:]')

    echo "$str"
}

# Converts string to upper case.
#
# parameters:
#   $1 string
function upper() {

    local str="$1"
    str=$(echo $str | tr '[:lower:]' '[:upper:]')

    echo "$str"
}

# Splits string and returns part given by the third argument.
#
# parameters:
#   $1 string
#   $2 split string
#   $3 part (index starts from 1)
function split_part() {

    echo $(echo $1 | awk '{ split($1,a,v1); print a[v2]; }' v1=$2 v2=$3)
}

################################################################################
## file routines
##

# Lists broken symbolic links recursively.
#
# parameters:
#   $1 directory (optional)
function list_broken_links() {

    local dir=$1
    [ -z "$dir" ] && dir=.

    local output=$((find $dir -type l ! -exec test -r {} \; -print) 2> /dev/null)
    for line in $output; do
        local str=$(ls -la $line 2> /dev/null | awk '{ print $9, $11}')
        local link=$(echo $str | awk '{ print $1 }')
        local file=$(echo $str | awk '{ print $2 }')
        echo "$link -> $file"
    done
}

# Removes string from the given file.
#
# parameters:
#   $1 string to remove
#   $2 file name
function remove_from_file() {

    local file=$TMP_DIR/remove_from_file.$$
    local str='1h;1!H;${;g;s/'
    sed -n "$str$1//g;p;}" $2 > $file && mv $file $2
}

# Replaces string by new string in the given file.
#
# parameters:
#   $1 string to search for
#   $2 new string
#   $3 file name
function replace_in_file() {

    local file=$TMP_DIR/replace_in_file.$$
    sed "s/$1/$2/g" $3 > $file && mv $file $3
}

# Checks if file contains the given string.
#
# parameters:
#   $1 string to search for (regular expression, multiline)
#   $2 file name
function file_contains() {

    local count=$(cat $2 | grep -P "$1" | wc -l)
    if [ $count -gt 0 ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Searches directory for files that contain the given string.
#
# parameters:
#   $1 string
#   $2 directory
function file_find_in() {

    local str=$1
    local dir=$2

    if [ "$dir" == "" ]; then
        find . -iname "*" | xargs grep -iR "$str" | \
            sort | uniq | grep -iR "$str"
    else
        find $dir -iname "*" | xargs grep -iR "$str" | \
            sort | uniq | grep -iR "$str"
    fi
}

# Replaces string in files in the given directory.
#
# parameters:
#   $1 old string
#   $2 new string
#   $3 directory (optional)
function file_replace_in() {

    local str1=$1
    local str2=$2
    local dir=$3

    if [ "$dir" == "" ]; then
        find . -type f -name "*" -exec sed -i 's/$str1/$str2/' {} \;
    else
        find $dir -type f -name "*" -exec sed -i 's/$str1/$str2/' {} \;
    fi
}

# Downloads file from the given URL address.
#
# parameters:
#   --url <url>                         url address of the file to download
#   --force                             force to download from the given url
#                                       address not using a cached file or
#                                       an alternative location
#   --file <name>                       name of an output file
#   --cache-dir-name <name>             cache directory name; file name in that
#                                       directory must match the file name given
#                                       as the parameter
#   --donwload-directory <directory>    destination directory, where the file
#                                       should be placed after download
#   --check-file-size <size>            check file size after download
#   --do-not-cache                      do not cache file locally
function file_download() {

    # variables
    local url=
    local force="N"
    local file=
    local cache_dir_name=$CACHE_DOWNLOADS_DIR
    local current_download_dir=./
    local file_size=0
    local do_not_cache="N"
    local current_dir=`pwd`

    # arguments
    while [ "$1" != "" ]; do
        case $1 in
            --url)                  shift; url=$1
                                    ;;
            --force)                force="Y"
                                    ;;
            --file)                 shift; file=$1
                                    ;;
            --cache-dir-name)       shift; cache_dir_name=$1
                                    ;;
            --donwload-directory)   shift; current_download_dir=$1
                                    ;;
            --check-file-size)      shift; file_size=$1
                                    ;;
            --do-not-cache)         do_not_cache="Y"
                                    ;;
        esac
        shift
    done

    # file may have already been downloaded
    if [ $force == "N" ] && [ -s $CACHE_DIR/$cache_dir_name/$file ] && \
            [ ! -s $current_download_dir/$file ]; then

        cp -f $CACHE_DIR/$cache_dir_name/$file $current_download_dir

    else

        # local network available, so try to download from a local storage
        if [ ! -s $CACHE_DIR/$cache_dir_name/$file ] && [[ "$IP_ADDRESS" == 192.168.* ]] && [ $force == "N" ]; then
            # try to download
            wget \
                --tries=1 \
                --connect-timeout=10 \
                --user="$LOCAL_DOWNLOAD_USER" \
                --password="$LOCAL_DOWNLOAD_PASS" \
                $LOCAL_DOWNLOAD_URL/$cache_dir_name/$file -O $file
            # cache file
            [ -s $file ] && mv -f $file $CACHE_DIR/$cache_dir_name
            # check file size
            if [ $file_size != 0 ] && [ -f $CACHE_DIR/$cache_dir_name/$file ]; then
                local size=$(ls -l $CACHE_DIR/$cache_dir_name/$file | awk '{ print $5 }')
                if [ $file_size -gt $size ]; then
                    rm $CACHE_DIR/$cache_dir_name/$file
                fi
            fi
        fi

        # try to download from the given url address
        if ([ -n "$url" ] && ([ ! -s $CACHE_DIR/$cache_dir_name/$file ] || [ $force == "Y" ])); then
            # try to download
            wget \
                --tries=1 \
                --connect-timeout=10 \
                $url -O $file
            # cache file
            [ -s $file ] && mv -f $file $CACHE_DIR/$cache_dir_name
            # check file size
            if [ $file_size != 0 ] && [ -f $CACHE_DIR/$cache_dir_name/$file ]; then
                local size=$(ls -l $CACHE_DIR/$cache_dir_name/$file | awk '{ print $5 }')
                if [ $file_size -gt $size ]; then
                    rm $CACHE_DIR/$cache_dir_name/$file
                fi
            fi
        fi

        # try to download from a custom location
        if [ ! -s $CACHE_DIR/$cache_dir_name/$file ] && [ $force == "N" ]; then
            # try to download
            wget \
                --tries=1 \
                --connect-timeout=10 \
                $ONLINE_DOWNLOAD_URL/$cache_dir_name/$file -O $file
            # cache file
            [ -s $file ] && mv -f $file $CACHE_DIR/$cache_dir_name
            # check file size
            if [ $file_size != 0 ] && [ -f $CACHE_DIR/$cache_dir_name/$file ]; then
                local size=$(ls -l $CACHE_DIR/$cache_dir_name/$file | awk '{ print $5 }')
                if [ $file_size -gt $size ]; then
                    rm $CACHE_DIR/$cache_dir_name/$file
                fi
            fi
        fi

        # set read only permission
        if [ -s $CACHE_DIR/$cache_dir_name/$file ]; then
            chmod 400 $CACHE_DIR/$cache_dir_name/$file
        fi

        # copy file to the current download directory
        if [ -s $CACHE_DIR/$cache_dir_name/$file ] && \
                [ ! -s $current_download_dir/$file ]; then
            cp -f $CACHE_DIR/$cache_dir_name/$file $current_download_dir
        fi

    fi

    # do not cache
    if [ "$do_not_cache" == "Y" ] && \
            [ -f $CACHE_DIR/$cache_dir_name/$file ]; then
        rm $CACHE_DIR/$cache_dir_name/$file
    fi

    # return value
    if [ -s $current_download_dir/$file ]; then
        echo "success"
    else
        rm $current_download_dir/$file > /dev/null 2>&1
        echo "error"
    fi

    cd $current_dir
}

# Validates SHA1 hash sum of a given file.
#
# parameters:
#   $1 file name
#   $2 sha1 hash sum
function file_is_hash_valid() {

    local file=$1
    local hash=$(lower $2)

    local current_hash=$(sha1sum $file)
    current_hash=$(lower $current_hash)

    if [ "$hash" == "$current_hash" ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Sets configuration option in a file.
#
# parameters:
#   $1 key
#   $2 value
#   $3 file
function file_set_conf_option() {

    local key=$1
    local value=$2
    local file=$3

    local line=$(cat $file | grep "^[ \t]*$key[ \t]*=")
    if [ -n "$line" ]; then
        replace_in_file "$line" "$key = $value" $file
    else
        echo "$key = $value" >> $file
    fi
}

# Gets configuration option from file.
#
# parameters:
#   $1 key
#   $2 file
function file_get_conf_option() {

    local key=$1
    local file=$2

    local line=$(cat $file | grep "^[ \t]*$key[ \t]*=")
    echo $line | sed -rn 's/^[a-zA-Z0-9_]+[ \t]*=[ \t]*(.*)$/\1/p'
}

################################################################################
## package routines
##

# Downloads package.
#
# parameters:
#   $1 package name
#   $2 donwload directory
#   --check-file-size <size>
function package_download() {

    local file=$(sanitise $1 '-' --allowed-characters '\.')${PACKAGE_SUFFIX}
    local current_download_dir=$CACHE_PACKAGES_DIR
    local file_size=0
    local current_dir=`pwd`

    # get minimum file size
    while [ "$1" != "" ]; do
        case $1 in
            --donwload-directory)   shift; current_download_dir=$1
                                    ;;
            --check-file-size)      shift; file_size=$1
                                    ;;
        esac
        shift
    done

    file_download --file $file --cache-dir-name "packages" --donwload-director $current_download_dir --check-file-size $file_size

    cd $current_dir
}

# Creates package from the given directory.
#
# parameters:
#   $1 source directory
#   $2 package name
function package_create() {

    local dir=$1
    local archive=$(sanitise $2 '-' --allowed-characters '\.')${PACKAGE_SUFFIX}
    local current_dir=`pwd`

    cd $dir/..
    tar -zcf $archive $(basename $dir)
    mv -v $archive $CACHE_PACKAGES_DIR
    chmod 400 $CACHE_PACKAGES_DIR/$archive

    cd $current_dir
}

# Creates package from files in the given directory.
#
# parameters:
#   $1 source directory
#   $2 package name
#   $3 files to be included in the package
function package_create_files() {

    local dir=$1
    local archive=$(sanitise $2 '-' --allowed-characters '\.')${PACKAGE_SUFFIX}
    local files=$3
    local current_dir=`pwd`

    cd $dir
    tar -zcf $archive $files
    mv -v $archive $CACHE_PACKAGES_DIR
    chmod 400 $CACHE_PACKAGES_DIR/$archive

    cd $current_dir
}

# Restores directory of the package.
#
# parameters:
#   $1 package name
function package_restore() {

    local name=$(sanitise $1 '-' --allowed-characters '\.')
    local archive=${name}${PACKAGE_SUFFIX}
    local dest_dir=$INSTALL_DIR
    local current_dir=`pwd`

    cd $CACHE_PACKAGES_DIR
    if [ -f $archive ]; then
        [ -d $name ] && rm -rf $name
        mkdir $name
        cp $archive $name
        cd $name
        tar -zxf $archive
        rm $archive
        local dir_name=$(ls -1)
        [ -d $dest_dir/$dir_name ] && rm -rf $dest_dir/$dir_name
        mv -v * $dest_dir
        cd ..
        rm -rf $name
    fi

    cd $current_dir
}

# Restores files of the package.
#
# parameters:
#   $1 package name
#   $2 destination directory of the package
function package_restore_files() {

    local name=$(sanitise $1 '-' --allowed-characters '\.')
    local archive=${name}${PACKAGE_SUFFIX}
    local dest_dir=$2
    local current_dir=`pwd`

    cd $CACHE_PACKAGES_DIR
    if [ -f $archive ] && [ -d $dest_dir ]; then
        cp $archive $dest_dir
        cd $dest_dir
        tar -zxvf $archive
        rm $archive
    fi

    cd $current_dir
}

# Adds version of the package.
#
# parameters:
#   $1 package name
#   $2 version
function package_add_version() {

    local file=$PACKAGES_FILE
    local pkg=$(sanitise $1 '-')
    local version=$(echo $2 | tr '[:upper:]' '[:lower:]')

    if [ -f $file ]; then
        cat $file | grep -v "$pkg=" > $file.tmp
        mv $file.tmp $file
    else
        touch $file
    fi
    echo "$pkg=$version" >> $file

    cat $file | grep -v '# ' | sort | uniq > $file.tmp
    mv $file.tmp $file

    _set_ownership $file
}

# Gets version of the package.
#
# parameters:
#   $1 package name
function package_get_version() {

    local pkg=$(sanitise $1 '-')

    local line=`cat $PACKAGES_FILE | grep "$pkg="`
    local len=`expr length $pkg`
    local pos=`expr $len + 1`
    local ver=${line:$pos}

    echo $ver
}

# Checks if the package is installed.
#
# parameters:
#   $1 package name
function package_is_installed() {

    local pkg=$(sanitise $1 '-')

    if [ -n "$(cat $PACKAGES_FILE | grep ^$pkg=.*)" ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Compares to versions of a package.
#
# parameters:
#   $1 version
#   $2 version
function package_compare_version() {

    if [[ $1 == $2 ]]; then
        echo 0
        return
    fi

    local IFS=.
    local i ver1=($1) ver2=($2)

    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++)); do
        if [[ -z ${ver2[i]} ]]; then
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]})); then
            echo 1
            return
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]})); then
            echo -1
            return
        fi
    done

    echo 0
}

################################################################################
## file hashes routines
##

# Adds directory to the list of hash directories.
#
# parameters:
#   $1 directory
function hashes_add_dir() {

    local file=$HASH_DIRECTORIES_FILE

    [ ! -f $file ] && touch $file
    echo $1 >> $file

    cat $file | grep -v '# ' | sort | uniq > $file.tmp
    mv $file.tmp $file

    _set_ownership $file
}

# Creates list of file hashes.
function hashes_create_list() {

    local file1=$HASH_DIRECTORIES_FILE
    local file2=$HASH_FILES_FILE

    [ -f $file2 ] && rm $file2
    while read dir; do
        [ -d $dir ] && find $dir -type f -name "*" | sort | xargs sha1sum >> $file2
    done < $file1
    [ ! -f $file2 ] && touch $file2

    _set_ownership $file2
}

# Counts bad hash files.
function hashes_count_bad() {

    local file=$HASH_FILES_FILE

    sha1sum -c $file | grep -v ': OK$' | wc -l
}

# Lists bad hash files.
function hashes_list_bad() {

    local file=$HASH_FILES_FILE

    sha1sum -c $file | grep -v ': OK$'
}

################################################################################
## version control routines
##

# Adds directory to the list of version control directories.
#
# parameters:
#   $1 directory
function repositories_add_dir() {

    local file=$REPOSITORIES_FILE

    [ ! -f $file ] && touch $file
    echo $1 >> $file

    cat $file | grep -v '# ' | sort | uniq > $file.tmp
    mv $file.tmp $file

    _set_ownership $file
}

################################################################################
## user management routines
##

# Creates a new system user.
#
# parameters:
#   $1 user
#   $2 uid
#   $3 group
#   $4 gid
#   --shell <shell>
function user_create() {

    local tmp_user=$1
    local tmp_uid=$2
    local tmp_group=$3
    local tmp_gid=$4

    # get shell
    local tmp_shell=/usr/sbin/nologin
    while [ "$1" != "" ]; do
        case $1 in
            --shell)    shift; tmp_shell=$1
                        ;;
        esac
        shift
    done

    groupadd -g $tmp_gid $tmp_group
    useradd -u $tmp_uid -d /dev/null -s $tmp_shell -g $tmp_group $tmp_user
}

# Checks if user exists.
#
# parameters:
#   $1 user
function user_exists() {

    if [ `grep "^$1:" /etc/passwd | wc -l` == "1" ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Checks if group exists.
#
# parameters:
#   $1 group
function group_exists() {

    if [ `grep "^$1:" /etc/group | wc -l` == "1" ]; then
        echo "yes"
    else
        echo "no"
    fi
}

################################################################################
## project specific routines
##

# Puts message in the system log.
#
# parameters:
#   $1 message
function log_info() {

    logger -p local0.notice -t shellos "$1"
}

# Puts error message in the system log.
#
# parameters:
#   $1 message
function log_error() {

    logger -p local0.err -t shellos "$1"
}

# Reloads common files.
function reload_common_files() {

    # functions
    source $SHELLOS_DIR/bin/functions
    # variables
    source $SHELLOS_DIR/conf/variables
    # versions
    source $SHELLOS_DIR/conf/versions
    # constants
    source $SHELLOS_DIR/bin/constants
    # aliases
    source $SHELLOS_DIR/bin/aliases
}

# Reloads crontab.
function reload_crontab() {

    (cat $SHELLOS_DIR/conf/.crontab-variables; cat $SHELLOS_DIR/conf/.crontab-jobs) | crontab
}

# Sets project configuration option.
#
# parameters:
#   $1 key
#   $2 value
function shellos_conf_set_option() {

    local key=$1
    local value=$2
    local file=$SHELLOS_CONF_FILE

    file_set_conf_option $key $value $file

    _set_ownership $file
}

# Gets project configuration option.
#
# parameters:
#   $1 key
function shellos_conf_get_option() {

    local key=$1
    local file=$SHELLOS_CONF_FILE

    file_get_conf_option $key $file
}

# Returns system type id.
#
# parameters:
#   $1 system type name
function system_type_name_to_id() {

    local name=$1

    if [ "$name" == "dedicated" ]; then
        echo $SYSTEM_TYPE_DEDICATED_ID
    elif [ "$name" == "kvm" ]; then
        echo $SYSTEM_TYPE_KVM_ID
    elif [ "$name" == "lxc" ]; then
        echo $SYSTEM_TYPE_LXC_ID
    else
        echo $SYSTEM_TYPE_NONE_ID
    fi
}

# Returns system type name.
#
# parameters:
#   $1 system type id
function system_type_id_to_name() {

    local id=$1

    if [ $id -eq $SYSTEM_TYPE_DEDICATED_ID ]; then
        echo "dedicated"
    elif [ $id -eq $SYSTEM_TYPE_KVM_ID ]; then
        echo "kvm"
    elif [ $id -eq $SYSTEM_TYPE_LXC_ID ]; then
        echo "lxc"
    else
        echo "none"
    fi
}

# Checks if the given system type has been assigned.
#
# parameters:
#   $1 system type id
function system_type_eq() {

    local id=$1

    if [ $id -eq $(system_type_name_to_id $SYSTEM_TYPE) ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Checks if the given system type has not been assigned.
#
# parameters:
#   $1 system type id
function system_type_ne() {

    local id=$1

    if [ $id -ne $(system_type_name_to_id $SYSTEM_TYPE) ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Returns system role id.
#
# parameters:
#   $1 role name
function role_name_to_id() {

    local name=$1

    if [ "$name" == "hypervisor" ]; then
        echo $ROLE_HYPERVISOR_ID
    elif [ "$name" == "node" ]; then
        echo $ROLE_NODE_ID
    elif [ "$name" == "hypernode" ]; then
        echo $ROLE_HYPERNODE_ID
    elif [ "$name" == "container" ]; then
        echo $ROLE_CONTAINER_ID
    elif [ "$name" == "personal" ]; then
        echo $ROLE_PERSONAL_ID
    elif [ "$name" == "mobile" ]; then
        echo $ROLE_MOBILE_ID
    elif [ "$name" == "control-device" ]; then
        echo $ROLE_CONTROL_DEVICE_ID
    else
        echo $ROLE_NONE_ID
    fi
}

# Returns role name.
#
# parameters:
#   $1 role id
function role_id_to_name() {

    local id=$1

    if [ $id -eq $ROLE_HYPERVISOR_ID ]; then
        echo "hypervisor"
    elif [ $id -eq $ROLE_NODE_ID ]; then
        echo "node"
    elif [ $id -eq $ROLE_HYPERNODE_ID ]; then
        echo "hypernode"
    elif [ $id -eq $ROLE_CONTAINER_ID ]; then
        echo "container"
    elif [ $id -eq $ROLE_PERSONAL_ID ]; then
        echo "personal"
    elif [ $id -eq $ROLE_MOBILE_ID ]; then
        echo "mobile"
    elif [ $id -eq $ROLE_CONTROL_DEVICE_ID ]; then
        echo "control-device"
    else
        echo "none"
    fi
}

# Checks if the given role has been assigned.
#
# parameters:
#   $1 role id
function role_eq() {

    local id=$1

    if [ $id -eq $(role_name_to_id $ROLE_NAME) ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Checks if the given role has not been assigned.
#
# parameters:
#   $1 role id
function role_ne() {

    local id=$1

    if [ $id -ne $(role_name_to_id $ROLE_NAME) ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Checks if the given role is greater than the assigned one.
#
# parameters:
#   $1 role id
function role_gt() {

    local id=$1

    if [ $id -gt $(role_name_to_id $ROLE_NAME) ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Checks if the given role is greater than or equal to the assigned one.
#
# parameters:
#   $1 role id
function role_ge() {

    local id=$1

    if [ $id -ge $(role_name_to_id $ROLE_NAME) ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Checks if the given role is lower than the assigned one.
#
# parameters:
#   $1 role id
function role_lt() {

    local id=$1

    if [ $id -lt $(role_name_to_id $ROLE_NAME) ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Checks if the given role is lower than or equal to the assigned one.
#
# parameters:
#   $1 role id
function role_le() {

    local id=$1

    if [ $id -le $(role_name_to_id $ROLE_NAME) ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Returns server aspect id.
#
# parameters:
#   $1 aspect name
function aspect_name_to_id() {

    local name=$1

    if [ "$name" == "system-update" ]; then
        echo $ASPECT_SYSTEM_UPDATE_ID
    elif [ "$name" == "system-management" ]; then
        echo $ASPECT_SYSTEM_MANAGEMENT_ID
    elif [ "$name" == "www-presentation" ]; then
        echo $ASPECT_WWW_PRESENTATION_ID
    elif [ "$name" == "www-service" ]; then
        echo $ASPECT_WWW_SERVICE_ID
    elif [ "$name" == "www-hosting" ]; then
        echo $ASPECT_WWW_HOSTING_ID
    elif [ "$name" == "security-jail" ]; then
        echo $ASPECT_SECURITY_JAIL_ID
    else
        echo $ASPECT_NONE_ID
    fi
}

# Returns server aspect name.
#
# parameters:
#   $1 aspect id
function aspect_id_to_name() {

    local id=$1

    if [ $id -eq $ASPECT_SYSTEM_UPDATE_ID ]; then
        echo "system-update"
    elif [ $id -eq $ASPECT_SYSTEM_MANAGEMENT_ID ]; then
        echo "system-management"
    elif [ $id -eq $ASPECT_WWW_PRESENTATION_ID ]; then
        echo "www-presentation"
    elif [ $id -eq $ASPECT_WWW_SERVICE_ID ]; then
        echo "www-service"
    elif [ $id -eq $ASPECT_WWW_HOSTING_ID ]; then
        echo "www-hosting"
    elif [ $id -eq $ASPECT_SECURITY_JAIL_ID ]; then
        echo "security-jail"
    else
        echo "none"
    fi
}

# Checks if the given aspect has been assigned.
#
# parameters:
#   $1 aspect id
function aspect_eq() {

    local id=$1

    if [ $id -eq $(aspect_name_to_id $ASPECT_NAME) ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Checks if the given aspect has not been assigned.
#
# parameters:
#   $1 aspect id
function aspect_ne() {

    local id=$1

    if [ $id -ne $(aspect_name_to_id $ASPECT_NAME) ]; then
        echo "yes"
    else
        echo "no"
    fi
}

################################################################################
## job routines
##

# Locks a single job.
#
# parameters:
#   $1 job name
function job_lock_set() {

    local job=$1
    local file=$JOB_LOCK_DIR/shellos-job-lock-$job.lock

    touch $file
    _set_ownership $file > /dev/null 2>&1
}

# Unlocks a single job.
#
# parameters:
#   $1 job name
function job_lock_unset() {

    local job=$1
    local file=$JOB_LOCK_DIR/shellos-job-lock-$job.lock

    rm $file > /dev/null 2>&1
}

# Checks if a lock exists on a single job.
#
# parameters:
#   $1 job name
function job_lock_exists() {

    local job=$1
    local file=$JOB_LOCK_DIR/shellos-job-lock-$job.lock

    if [ -f $file ] || [ -f $JOB_LOCK_ALL_FILE ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Locks all jobs.
function job_lock_all() {

    touch $JOB_LOCK_ALL_FILE
    _set_ownership $JOB_LOCK_ALL_FILE > /dev/null 2>&1

    log_info "all jobs are locked"
}

# Unlocks all jobs.
function job_unlock_all() {

    rm $JOB_LOCK_DIR/shellos-job-lock-*.lock > /dev/null 2>&1
    rm $JOB_LOCK_ALL_FILE > /dev/null 2>&1

    log_info "all jobs are unlocked"
}

# Checks if all jobs are locked.
function job_lock_all_exists() {

    if [ -f $JOB_LOCK_ALL_FILE ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Lists all locked jobs.
#
# parameters:
#   $1 job to exclude from list (optional)
function job_lock_list() {

    if [ -f $JOB_LOCK_ALL_FILE ]; then
        echo "all jobs are locked"
    else
        local LOCKS=`find $JOB_LOCK_DIR -iname shellos-job-lock-*.lock | sort`
        for LOCK in $LOCKS; do
            if [ -z "$1" ]; then
                echo $( basename $LOCK .lock ) | cut -c18-50
            else
                if [ "$( basename $LOCK .lock )" != "shellos-job-lock-$1" ]; then
                    echo $( basename $LOCK .lock ) | cut -c18-50
                fi
            fi
        done
    fi
}

################################################################################
## firewall routines
##

# Sets firewall mode.
#
# parameters:
#   $1 mode
function firewall_set_mode() {

    local mode="$1"
    local file=$FIREWALL_MODE_FILE

    echo "$mode" > $file
    _set_ownership $file > /dev/null 2>&1

    # log event
    log_info "firewall mode changed to '$mode'"

    $CMD_FIREWALL_START
}

# Gets firewall mode.
function firewall_get_mode() {

    local file=$FIREWALL_MODE_FILE

    if [ -f $file ]; then
        cat $file
    else
        echo "safe"
    fi
}

# Switches firewall mode to online.
function firewall_set_online_mode() {

    firewall_set_mode "online"
}

# Switches firewall mode to safe.
function firewall_set_safe_mode() {

    firewall_set_mode "safe"
}

# Switches firewall mode to offline.
function firewall_set_offline_mode() {

    firewall_set_mode "offline"
}

################################################################################
## service routines
##

# Starts or stops a service.
#
# parameters:
#   $1 service name
#   $2 start command
#   $3 pid search string
#   $4 action
#   --not "pid string not to search for"
function service_monitor() {

    local name="$1"
    local cmd_start="$2"
    local pid_str="$3"
    local action="$4"
    local pid_not_str=$(random 8)
    # log_errors - additional variable set elsewhere, ie. system-services job

    while [ "$1" != "" ]; do
        case $1 in
            --not)  shift; pid_not_str=$1
                    ;;
        esac
        shift
    done

    local pid=`ps ax | grep -v "$pid_not_str" | grep "$pid_str" | grep -v grep | cut -c1-5 | paste -s -`
    # start
    if [ ! "$pid" ] && [ "$action" == "start" ]; then
        [ "$log_errors" == "Y" ] && log_error "service $name not running"
        log_info "start service $name \"$cmd_start\""
        ($cmd_start) > /dev/null 2>&1
        if [ "$log_errors" == "Y" ]; then
            sleep 3
            pid=`ps ax | grep -v "$pid_not_str" | grep "$pid_str" | grep -v grep | cut -c1-5 | paste -s -`
            if [ ! "$pid" ]; then
                log_error "service $name NOT started!"
            fi
        fi
    # stop
    elif [ "$pid" ] && [ "$action" == "stop" ]; then
        log_info "stop service $name"
        kill -9 $pid
    fi
}

# Checks if a service is running.
#
# parameters:
#   $1 pid search string
#   --not "pid string not to search for"
function is_running() {

    local pid_str="$1"
    local pid_not_str=$(random 8)

    while [ "$1" != "" ]; do
        case $1 in
            --not)  shift; pid_not_str=$1
                    ;;
        esac
        shift
    done

    local pid=`ps ax | grep -v "$pid_not_str" | grep "$pid_str" | grep -v grep | cut -c1-5 | paste -s -`
    if [ -n "$pid" ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# is_running_*()

# Checks if openssh is running.
function is_running_openssh() {

    is_running "$PID_OPENSSH_PROC_STR"
}

# Checks if openssh agent is running.
function is_running_openssh_agent() {

    is_running "$PID_OPENSSH_AGENT_PROC_STR"
}

# Checks if openvpn is running.
function is_running_openvpn() {

    is_running "$PID_OPENVPN_PROC_STR"
}

# Checks if mysql is running.
function is_running_mysql() {

    is_running "$PID_MYSQL_PROC_STR"
}

# Checks if postfix is running.
function is_running_postfix() {

    is_running "$PID_POSTFIX_PROC_STR"
}

# Checks if httpd is running.
function is_running_httpd() {

    is_running "$PID_APACHECTL_PROC_STR"
}

# Checks if proftpd is running.
function is_running_proftpd() {

    is_running "$PID_PROFTPD_PROC_STR" --not "log-proftpd.pl"
}

# Checks if dovecot is running.
function is_running_dovecot() {

    is_running "$PID_DOVECOT_PROC_STR"
}

# Checks if tomcat is running.
function is_running_tomcat() {

    is_running "$PID_TOMCAT_PROC_STR"
}

# start_*()

# Starts openssh service.
function start_openssh() {

    service_monitor "OpenSSH" "$CMD_OPENSSH_START" "$PID_OPENSSH_PROC_STR" "start"
}

# Starts openssh agent service.
function start_openssh_agent() {

    service_monitor "OpenSSH Agent" "$CMD_OPENSSH_AGENT_START" "$PID_OPENSSH_AGENT_PROC_STR" "start"
}

# Starts openvpn service.
function start_openvpn() {

    service_monitor "OpenVPN" "$CMD_OPENVPN_START" "$PID_OPENVPN_PROC_STR" "start"
}

# Starts mysql service.
function start_mysql() {

    # TODO: this should be executed on reboot (hook)

    # geoip
    if [ ! -d ${HTTPD_CHROOT_DIR}${INSTALL_DIR}/geoip/share/GeoIP ]; then
        mkdir -p ${HTTPD_CHROOT_DIR}${INSTALL_DIR}/geoip/share/GeoIP
    fi
    if [ ! -f ${HTTPD_CHROOT_DIR}${INSTALL_DIR}/geoip/share/GeoIP/GeoIPCity.dat ]; then
        ln $INSTALL_DIR/geoip/share/GeoIP/GeoIPCity.dat ${HTTPD_CHROOT_DIR}${INSTALL_DIR}/geoip/share/GeoIP/GeoIPCity.dat
    fi

    # mysql
    if [ ! -d ${HTTPD_CHROOT_DIR}${INSTALL_DIR}/mysql/log ]; then
        mkdir -p ${HTTPD_CHROOT_DIR}${INSTALL_DIR}/mysql/log
    fi
    if [ ! -S ${HTTPD_CHROOT_DIR}${INSTALL_DIR}/mysql/log/mysql.sock ]; then
        ln $INSTALL_DIR/mysql/log/mysql.sock ${HTTPD_CHROOT_DIR}${INSTALL_DIR}/mysql/log/mysql.sock
    fi

    service_monitor "MySQL" "$CMD_MYSQL_START" "$PID_MYSQL_PROC_STR" "start"
}

# Starts postfix service.
function start_postfix() {

    service_monitor "Postfix" "$CMD_POSTFIX_START" "$PID_POSTFIX_PROC_STR" "start"
}

# Starts httpd service.
function start_httpd() {

    # TODO: this should be executed on reboot (hook)

    # /lib
    if [ "$(mount -l | grep $HTTPD_CHROOT_DIR/lib | wc -l)" -eq 0 ]; then
        mount --bind /lib $HTTPD_CHROOT_DIR/lib
        mount -o remount,ro $HTTPD_CHROOT_DIR/lib
    fi
    # /usr/lib
    if [ "$(mount -l | grep $HTTPD_CHROOT_DIR/usr/lib | wc -l)" -eq 0 ]; then
        mount --bind /usr/lib $HTTPD_CHROOT_DIR/usr/lib
        mount -o remount,ro $HTTPD_CHROOT_DIR/usr/lib
    fi

    service_monitor "Apache HTTPD Server" "$CMD_APACHECTL_START" "$PID_APACHECTL_PROC_STR" "start"
}

# Starts proftpd service.
function start_proftpd() {

    local pid=`ps ax | grep "log-proftpd.pl" | grep -v grep | cut -c1-5 | paste -s -`
    if [ ! "$pid" ]; then
        nohup $SHELLOS_DIR/bin/log-proftpd.pl > /dev/null 2>&1 &
    fi
    service_monitor "ProFTPD" "$CMD_PROFTPD_START" "$PID_PROFTPD_PROC_STR" "start" --not "log-proftpd.pl"
}

# Starts dovecot service.
function start_dovecot() {

    service_monitor "Dovecot" "$CMD_DOVECOT_START" "$PID_DOVECOT_PROC_STR" "start"
}

# Starts tomcat service.
function start_tomcat() {

    service_monitor "Tomcat" "$CMD_TOMCAT_START" "$PID_TOMCAT_PROC_STR" "start"
}

# stop_*()

# Stops openssh service.
function stop_openssh() {

    service_monitor "OpenSSH" "$CMD_OPENSSH_START" "$PID_OPENSSH_PROC_STR" "stop"
}

# Stops openssh agent service.
function stop_openssh_agent() {

    service_monitor "OpenSSH Agent" "$CMD_OPENSSH_AGENT_START" "$PID_OPENSSH_AGENT_PROC_STR" "stop"
}

# Stops openvpn service.
function stop_openvpn() {

    service_monitor "OpenVPN" "$CMD_OPENVPN_START" "$PID_OPENVPN_PROC_STR" "stop"
}

# Stops mysql service.
function stop_mysql() {

    service_monitor "MySQL" "$CMD_MYSQL_START" "$PID_MYSQL_PROC_STR" "stop"
}

# Stops postfix service.
function stop_postfix() {

    service_monitor "Postfix" "$CMD_POSTFIX_START" "$PID_POSTFIX_PROC_STR" "stop"
}

# Stops httpd service.
function stop_httpd() {

    service_monitor "Apache HTTPD Server" "$CMD_APACHECTL_START" "$PID_APACHECTL_PROC_STR" "stop"
}

# Stops proftpd service.
function stop_proftpd() {

    service_monitor "ProFTPD" "$CMD_PROFTPD_START" "$PID_PROFTPD_PROC_STR" "stop"
}

# Stops dovecot service.
function stop_dovecot() {

    service_monitor "Dovecot" "$CMD_DOVECOT_START" "$PID_DOVECOT_PROC_STR" "stop"
}

# Stops tomcat service.
function stop_tomcat() {

    service_monitor "Tomcat" "$CMD_TOMCAT_START" "$PID_TOMCAT_PROC_STR" "stop"
}

# restart_*()

# Restarts openssh service.
function restart_openssh() {

    stop_openssh
    sleep 1
    start_openssh
}

# Restarts openssh agent service.
function restart_openssh_agent() {

    stop_openssh_agent
    sleep 1
    start_openssh_agent
}

# Restarts openvpn service.
function restart_openvpn() {

    stop_openvpn
    sleep 1
    start_openvpn
}

# Restarts mysql service.
function restart_mysql() {

    stop_mysql
    sleep 1
    start_mysql
}

# Restarts postfix service.
function restart_postfix() {

    stop_postfix
    sleep 1
    start_postfix
}

# Restarts httpd service.
function restart_httpd() {

    stop_httpd
    sleep 1
    start_httpd
}

# Restarts proftpd service.
function restart_proftpd() {

    stop_proftpd
    sleep 1
    start_proftpd
}

# Restarts dovecot service.
function restart_dovecot() {

    stop_dovecot
    sleep 1
    start_dovecot
}

# Restarts tomcat service.
function restart_tomcat() {

    stop_tomcat
    sleep 1
    start_tomcat
}

################################################################################
## mysql routines
##

# Adds user and password pair to a flat file.
#
# parameters:
#   $1 user name
#   $2 password
function mysql_add_user_password() {

    local file=$DATABASE_USERS_FILE
    local user=$1
    local new_pass=$2
    local old_pass=`mysql_get_user_password $1`

    if [ -z "$old_pass" ]; then
        [ ! -f $file ] && touch $file
        echo "$user=$new_pass" >> $file
        touch $file.tmp
        _set_ownership $file.tmp
        cat $file | grep -v '# ' | sort | uniq > $file.tmp
        mv $file.tmp $file
    else
        replace_in_file $old_pass $new_pass $file
    fi

    _set_ownership $file

    log_info "database user '$user' password changed"
}

# Returns user password stored in a flat file.
#
# parameters:
#   $1 user name
function mysql_get_user_password() {

    local line=`cat $DATABASE_USERS_FILE | grep "$1="`
    local len=`expr length $1`
    local pos=`expr $len + 1`
    local pass=${line:$pos}

    echo $pass
}

# Backups database to flat SQL files.
#
# parameters:
#   $1 database name
#   $2 output directory
function mysql_backup_database_to_files() {

    local db_name=$1
    local db_pass=$(mysql_get_user_password root)

    local list=$(echo "use $db_name; show tables;" | $CMD_MYSQL --user=root --password=$db_pass | awk '{ if ( NR > 1  ) { print } }')
    for item in $list; do
        local collation=$(echo "select ccsa.character_set_name from information_schema.tables t, information_schema.collation_character_set_applicability ccsa where ccsa.collation_name = t.table_collation and t.table_schema = '$db_name' and t.table_name = '$item';" | $CMD_MYSQL --user=root --password=$db_pass | awk '{ if ( NR > 1  ) { print } }')
        $CMD_MYSQLDUMP --user="root" --password="$db_pass" --default-character-set="$collation" --extended-insert=FALSE --skip-comments "$db_name" "$item" > $2/$item.sql
        chmod 400 $2/$item.sql
    done

    log_info "database '$db_name' backed up to files"
}

# Restores database from flat SQL files.
#
# parameters:
#   $1 input directory
#   $2 database name
function mysql_restore_database_from_files() {

    local db_name=$2
    local db_pass=$(mysql_get_user_password root)

    local list=$(ls $1/*.sql)
    for item in $list; do
        $CMD_MYSQL --user="root" --password="$db_pass" "$db_name" < $item
    done

    log_info "database '$db_name' restored from files"
}

# Backups database to an archive (flat SQL files).
#
# parameters:
#   $1 database name
#   $2 output archive file
function mysql_backup_database_to_archive() {

    local db_name=$1
    local db_pass=$(mysql_get_user_password root)

    local list=$(echo "use $db_name; show tables;" | $CMD_MYSQL --user=root --password=$db_pass | awk '{ if ( NR > 1  ) { print } }')
    for item in $list; do
        local collation=$(echo "select ccsa.character_set_name from information_schema.tables t, information_schema.collation_character_set_applicability ccsa where ccsa.collation_name = t.table_collation and t.table_schema = '$db_name' and t.table_name = '$item';" | $CMD_MYSQL --user=root --password=$db_pass | awk '{ if ( NR > 1  ) { print } }')
        $CMD_MYSQLDUMP --user="root" --password="$db_pass" --default-character-set="$collation" --extended-insert=FALSE --skip-comments "$db_name" "$item" > $item.sql
    done
    local count=$(ls *.sql | wc -l)
    if [ $count -gt 0 ]; then
        [ -f $2 ] && rm $2
        tar -zcf $2 *.sql
        chmod 400 $2
        rm *.sql
    fi

    log_info "database '$db_name' backed up to archive"
}

# Restores database from an archive (flat SQL files).
#
# parameters:
#   $1 input archive file
#   $2 database name
function mysql_restore_database_from_archive() {

    local db_name=$2
    local db_pass=$(mysql_get_user_password root)

    tar -zxf $1
    local list=$(ls *.sql)
    for item in $list; do
        $CMD_MYSQL --user="root" --password="$db_pass" "$db_name" < $item
    done
    rm *.sql

    log_info "database '$db_name' restored from archive"
}

# Restores database from an archive (flat SQL files) with table prefix.
#
# parameters:
#   $1 input archive file
#   $2 database name
#   $3 table prefix
function mysql_restore_database_from_file_prefix() {

    local db_name=$2
    local prefix=$3
    local db_pass=$(mysql_get_user_password root)

    tar -zxf $1
    local list=$(ls *.sql)
    for item in $list; do
        local basename=$( basename $item .sql )
        replace_in_file "\`$basename\`" "\`$3$basename\`" $item
        $CMD_MYSQL --user="root" --password="$db_pass" "$db_name" < $item
    done
    rm *.sql

    log_info "database '$db_name' restored from archive with table prefix '$prefix'"
}

# Copies tables across databases.
#
# parameters:
#   $1 source database
#   $2 destination database
function mysql_copy_tables() {

    [ "$1" == "$2" ] && exit 1

    local db_pass=$(mysql_get_user_password root)

    local list=$(echo "use $1; show tables;" | $CMD_MYSQL --user=root --password=$db_pass | awk '{ if ( NR > 1  ) { print } }')
    for item in $list; do
        local collation=$(echo "select ccsa.character_set_name from information_schema.tables t, information_schema.collation_character_set_applicability ccsa where ccsa.collation_name = t.table_collation and t.table_schema = '$1' and t.table_name = '$item';" | $CMD_MYSQL --user=root --password=$db_pass | awk '{ if ( NR > 1  ) { print } }')
        $CMD_MYSQLDUMP --user="root" --password="$db_pass" --default-character-set="$collation" --extended-insert=FALSE --skip-comments "$1" "$item" | $CMD_MYSQL --user="root" --password="$db_pass" "$2"
    done

    log_info "database tables copied from '$1' to '$2'"
}

# Creates database.
#
# parameters:
#   $1 database name
function mysql_create_database() {

    local db_name=$1
    local db_pass=$(mysql_get_user_password root)

    cat <<EOF | $CMD_MYSQL --user="root" --password="$db_pass"
create database $db_name;
EOF

    log_info "database '$db_name' created"
}

# Drops database.
#
# parameters:
#   $1 database name
function mysql_drop_database() {

    local db_name=$1
    local db_pass=$(mysql_get_user_password root)

    cat <<EOF | $CMD_MYSQL --user="root" --password="$db_pass"
drop database if exists $db_name;
EOF

    log_info "database '$db_name' dropped"
}

# Creates database user.
#
# parameters:
#   $1 databases name
#   $2 user name
#   $3 user password
function mysql_create_user() {

    local db_user=$2
    local db_pass=$(mysql_get_user_password root)

    for DB in $1; do
        cat <<EOF | $CMD_MYSQL --user="root" --password="$db_pass"
grant all on $DB.* to '$db_user'@'localhost' identified by '$3';
EOF
    done

    log_info "database user '$db_user' created"
}

# Drops database user.
#
# parameters:
#   $1 user name
function mysql_drop_user() {

    local db_user=$1
    local db_pass=$(mysql_get_user_password root)

    cat <<EOF | $CMD_MYSQL --user="root" --password="$db_pass"
drop user '$db_user'@'localhost';
EOF

    log_info "database user '$db_user' dropped"
}

# Lists all databases.
function mysql_list_databases() {

    local db_pass=$(mysql_get_user_password root)

    local list=$(echo "show databases;" | $CMD_MYSQL --user=root --password=$db_pass | awk '{ if ( NR > 1 ) { print } }')
    for item in $list; do
        echo $item
    done
}

# Lists database tables.
#
# parameters:
#   $1 database name
function mysql_list_tables() {

    local db_pass=$(mysql_get_user_password root)

    local list=$(echo "use $1; show tables;" | $CMD_MYSQL --user=root --password=$db_pass | awk '{ if ( NR > 1  ) { print } }')
    for item in $list; do
        echo $item
    done
}

# Checks if database exists.
#
# parameters:
#   $1 database name
function mysql_database_exists() {

    local count=$(mysql_list_databases | grep "^$1$" | wc -l)
    if [ "$count" == "0" ]; then
        echo "no"
    else
        echo "yes"
    fi
}

# Optimizes database tables.
#
# parameters:
#   $1 database name
function mysql_optimize_tables() {

    local db_pass=$(mysql_get_user_password root)

    local list=$(mysql_list_tables $1)
    for item in $list; do
        echo "use $1; optimize table $item;" | $CMD_MYSQL --user=root --password=$db_pass
    done
}

# Runs SQL query and returns single value.
#
# parameters:
#   $1 sql query
function mysql_query_value() {

    local sql=$1

    echo "$1" | $CMD_MYSQL --user=root --password=$(mysql_get_user_password root) | awk '{ if ( NR > 1  ) { print } }'
}

################################################################################
## httpd routines
##

# Creates httpd vhost.
#
# parameters:
#   $1 account type (account|application)
#   $2 user name
#   $3 ip address
#   $4 domain name
#   $5 document root
function httpd_vhost_create {

    local vhost_account_type=$1
    local vhost_user_name=$2
    local vhost_ip_address=$4
    local vhost_domain_name=$4
    local vhost_document_root=$5

    local vhost=$(cat <<END_HEREDOC
\tServerAlias www.$vhost_domain_name
\tDocumentRoot $vhost_document_root
\t<Directory $vhost_document_root>
\t\tOptions Indexes FollowSymLinks
\t\tAllowOverride All
\t\tOrder allow,deny
\t\tAllow from all
\t</Directory>
END_HEREDOC
)
    httpd_vhost_remove.pl -s "httpd" -t "$vhost_account_type" -n "$vhost_user_name" \
        -i "$vhost_ip_address" -d "$vhost_domain_name" -p 80
    httpd_vhost_create.pl -s "httpd" -t "$vhost_account_type" -n "$vhost_user_name" \
        -i "$vhost_ip_address" -d "$vhost_domain_name" -p 80 -c "$vhost"

    local vhost=$(cat <<END_HEREDOC
\tDocumentRoot $vhost_document_root
\t<Directory $vhost_document_root>
\t\tOptions Indexes FollowSymLinks
\t\tAllowOverride All
\t\tOrder allow,deny
\t\tAllow from all
\t</Directory>
\tSSLEngine on
\tSSLCertificateFile $SHELLOS_DIR/var/certificates/$vhost_domain_name.pem
\tSSLCertificateKeyFile $SHELLOS_DIR/var/certificates/$vhost_domain_name.key
END_HEREDOC
)
    httpd_vhost_remove.pl -s "httpd" -t "$vhost_account_type" -n "$vhost_user_name" \
        -i "$vhost_ip_address" -d "$vhost_domain_name" -p 443
    httpd_vhost_create.pl -s "httpd" -t "$vhost_account_type" -n "$vhost_user_name" \
        -i "$vhost_ip_address" -d "$vhost_domain_name" -p 443 -c "$vhost"

    generate_certificate $vhost_domain_name
}

################################################################################
## network routines
##

# Gets deafult network interface.
function network_get_interface() {

    local iface=""

    local ip=""
    if [ -z "$iface" ]; then
        ip=$(ifconfig eth0 | grep "inet addr" | awk -F: '{print $2}' | awk '{print $1}')
        if [ -z "$ip" ]; then
            ip=$(ifconfig br0 | grep "inet addr" | awk -F: '{print $2}' | awk '{print $1}')
            if [ -z "$ip" ]; then
                echo "unknown"
            else
                echo "br0"
            fi
        else
            echo "eth0"
        fi
    fi
}

# Prints IP address assigned to the given interface.
#
# parameters:
#   $1 network interface (default are eth0 or br0)
function network_get_ip() {

    local iface=""
    [ -n "$1" ] && iface=$1

    local ip=""
    if [ -z "$iface" ]; then
        ip=$(ifconfig eth0 | grep "inet addr" | awk -F: '{print $2}' | awk '{print $1}')
        if [ -z "$ip" ]; then
            ip=$(ifconfig br0 | grep "inet addr" | awk -F: '{print $2}' | awk '{print $1}')
        fi
    else
        ip=$(ifconfig $iface | grep "inet addr" | awk -F: '{print $2}' | awk '{print $1}')
    fi
    echo $ip
}

# Prints MAC address assigned to the given interface.
#
# parameters:
#   $1 network interface (default is eth0)
function network_get_mac() {

    local iface="eth0"
    [ -n "$1" ] && iface=$1

    local mac=$(ifconfig $iface | grep $iface | awk '{print $5}')

    echo $(lower $mac)
}

# Checks if network responds to ping.
#
# parameters:
#   $1 ip address
function network_is_responding() {

    local ip=$1

    if [ $(ping -c 1 $ip | grep "100% packet loss" | wc -l) -eq 0 ]; then
        echo "yes"
    else
        echo "no"
    fi
}

# Converts network mask to CIRD notation.
#
# parameters:
#   $1 netmask xxx.xxx.xxx.xxx
function network_mask2cidr() {

    local nbits=0
    local old_ifs=$IFS

    IFS=.
    for dec in $1 ; do
        case $dec in
            255) let nbits+=8;;
            254) let nbits+=7;;
            252) let nbits+=6;;
            248) let nbits+=5;;
            240) let nbits+=4;;
            224) let nbits+=3;;
            192) let nbits+=2;;
            128) let nbits+=1;;
            0);;
        esac
    done
    IFS=$old_ifs

    echo $nbits
}

# Converts network mask from CIRD notation.
#
# parameters:
#   $1 netmask yy
function network_cidr2mask() {

    local i mask=""
    local full_octets=$(($1/8))
    local partial_octet=$(($1%8))

    for ((i=0;i<4;i+=1)); do
        if [ $i -lt $full_octets ]; then
            mask+=255
        elif [ $i -eq $full_octets ]; then
            mask+=$((256 - 2**(8-$partial_octet)))
        else
            mask+=0
        fi
        test $i -lt 3 && mask+=.
    done

    echo $mask
}

################################################################################
## hardware routines
##

# Returns number of cpus.
function cpu_count() {

    local count=$(cat /proc/cpuinfo | grep "physical id" | sort -u | wc -l)

    echo $count
}

# Returns number of cores.
function cpu_core_count() {

    local count=$(cat /proc/cpuinfo | grep "core id" | sort -u | wc -l)

    echo $count
}

# Returns memory size. Size unit is included at the end.
function memory_get_size() {

    local size=$(cat /proc/meminfo | grep "MemTotal:" | awk '{ print $2 }')
    size=$(expr $size / 1000)

    echo ${size}MB
}

# Returns size of given drive or /dev/sda or /dev/xvda. Size unit is included at the end.
#
# parameters:
#   $1 drive path (optional)
function drive_get_size() {

    local device=
    if [ -n "$1" ]; then
        device=$1
    else
        [ $(ls -l /dev/sda 2> /dev/null | wc -l) -gt 0 ] && device=/dev/sda
        [ $(ls -l /dev/xvda 2> /dev/null | wc -l) -gt 0 ] && device=/dev/xvda
    fi

    local size=$(fdisk -l 2> /dev/null | grep "Disk $device:" | awk '{ print $3 }')
    size=${size/.*}

    echo ${size}GB
}

# Returns size of partition.
#
# parameters:
#   $1 partition path
function partition_get_size() {

    local partition=$1

    local size=$(df -H | grep $partition | awk '{ print $2 }')
    size=$(echo $size | sed s/.$//)
    size=${size/.*}

    echo ${size}GB
}

# Returns size number.
#
# parameters:
#   $1 string
function size_get_number() {

    local size=$1

    echo $size | sed -rn 's/^([0-9]+)[a-zA-Z]+/\1/p'
}

# Returns size unit.
#
# parameters:
#   $1 string
function size_get_unit() {

    local size=$1

    echo $size | sed -rn 's/^[0-9]+([a-zA-Z]+)/\1/p'
}

# List hard drives.
function hard_drive_list() {

    find /dev/disk/by-id/ -type l -iname \*ata\* -print0 | xargs -0 -iD readlink -f D | sort | uniq | grep -vP "\d$"
}

# Returns number of hard drives.
function hard_drive_count() {

    local count=$(hard_drive_list | wc -l)

    echo $count
}

# List usb drives.
function usb_drive_list() {

    find /dev/disk/by-path/ -type l -iname \*usb\*scsi\* -print0 | xargs -0 -iD readlink -f D
}

# Returns number of usb drives.
function usb_drive_count() {

    local count=$(usb_drive_list | wc -l)

    echo $count
}

# Reboots system. This function should be overwritten in the role specific script.
function system_reboot() {

    # TODO: generate an event

    reboot
}

################################################################################
## security routines
##

# Generates X.509 certificate.
#
# parameters:
#   $1 certificate name
#   $2 size of the certificate (default is 4096)
#   $3 for how many days the certificate remains valid (default is 3650)
function generate_certificate() {

    # size
    local size=4096
    [ -n "$2" ] && size=$2

    # days
    local days=3650
    [ -n "$3" ] && days=$3

    $CMD_OPENSSL req \
        -new -x509 -nodes -sha1 -newkey rsa:$size -days $days -subj "/O=unknown/OU=unknown/CN=$1" \
        -keyout $CERTIFICATES_DIR/$1.key \
        -out $CERTIFICATES_DIR/$1.crt
    cat $CERTIFICATES_DIR/$1.crt $CERTIFICATES_DIR/$1.key > $CERTIFICATES_DIR/$1.pem
    chmod 400 $CERTIFICATES_DIR/$1.{crt,key,pem}
}

################################################################################
## development routines
##

# Strips debugging symbols from binary files.
#
# parameters:
#   $1 directory or file
function development_strip_symbols() {

    if [ -d $1 ]; then
        du -ch $1/* | grep total
        strip --strip-debug $1/*
        du -ch $1/* | grep total
    elif [ -f $1 ]; then
        strip --strip-debug $1
    fi
}

# Creates links to *.so and *.a files in propriate system library directories.
#
# parameters:
#   $1 directory
#   --symbolic
function development_link_libraries() {

    local dir=$1
    local count_so=$(ls -la $dir/*.so* 2> /dev/null | wc -l)
    local count_a=$(ls -la $dir/*.a 2> /dev/null | wc -l)
    local symbolic=""

    # arguments
    while [ "$1" != "" ]; do
        case $1 in
            --symbolic) symbolic="s"
                        ;;
        esac
        shift
    done

    # /lib
    [ "$count_so" -gt 0 ] && ln -${symbolic}fv $dir/*.so* /lib/
    if [ -d /lib/x86_64-linux-gnu ]; then
        [ "$count_so" -gt 0 ] && ln -${symbolic}fv $dir/*.so* /lib/x86_64-linux-gnu/
    fi

    # /usr/lib
    [ "$count_so" -gt 0 ] && ln -${symbolic}fv $dir/*.so* /usr/lib/
    [ "$count_a" -gt 0 ] && ln -${symbolic}fv $dir/*.a /usr/lib/
    if [ -d /usr/lib/x86_64-linux-gnu ]; then
        [ "$count_so" -gt 0 ] && ln -${symbolic}fv $dir/*.so* /usr/lib/x86_64-linux-gnu/
        [ "$count_a" -gt 0 ] && ln -${symbolic}fv $dir/*.a /usr/lib/x86_64-linux-gnu/
    fi
}

# Lists executable file dependencies.
#
# parameters:
#   $1 executable file
function chroot_dependencies_list() {

    local bin=$1

    local output=$(ldd $bin)
    for line in $output; do
        echo $line | grep "^/"
    done
}

# Lists executable file dependencies (recursively).
#
# parameters:
#   $1 executable file
function chroot_dependencies_list_all() {

    local bin=$1

    (

        local output=$(development_list_dependencies $bin)
        for file in $output; do
            echo "$file"
            chroot_dependencies_all $file
        done

    ) 2> /dev/null | grep "^/" | sort | uniq
}

# Copies executable file dependencies (recursively) to chroot directory.
#
# parameters:
#   $1 executable file
#   $2 chroot directory
function chroot_dependencies_copy() {

    local bin=$1
    local dir=$2

    local output=$(chroot_dependencies_list_all $bin)
    for file in $output; do
        echo "$file"
        mkdir -p $dir/$(dirname $file)
        cp $file $dir/$(dirname $file)
    done
}

################################################################################
## include role specific functions
##

[ -f $SHELLOS_DIR/bin/functions.$ROLE_NAME ] && \
    source $SHELLOS_DIR/bin/functions.$ROLE_NAME

################################################################################
## include custom functions
##

[ -f $SHELLOS_DIR/bin/functions.custom ] && \
    source $SHELLOS_DIR/bin/functions.custom
